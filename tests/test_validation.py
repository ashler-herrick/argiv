"""Validate argiv.compute_greeks against QuantLib-Python.

Both argiv (C++/BlackCalculator) and QuantLib-Python (AnalyticEuropeanEngine)
solve the same BSM model analytically. However, QuantLib-Python computes T
from discrete dates (today + Period(days)) while argiv takes T directly as a
float, introducing small day-count rounding differences. This means we compare
at the 99th-percentile level rather than expecting exact agreement.

The synthetic dataset is generated by benchmarks.bench_greeks.generate_dataset
using known BS prices from known sigmas, so IV recovery can also be verified.
"""

import math

import numpy as np
import pytest
import QuantLib as ql

import argiv
from argiv.helpers import generate_dataset

INPUT_COLS = [
    "option_type", "spot", "strike", "expiry",
    "rate", "dividend_yield", "market_price",
]

N_ROWS = 1000


def _true_sigmas(n):
    """Reproduce the true sigmas from generate_dataset(n) with seed=42."""
    rng = np.random.default_rng(42)
    rng.choice([1, -1], size=n)       # option_type
    rng.uniform(80.0, 120.0, size=n)  # strike
    rng.uniform(0.1, 2.0, size=n)     # expiry
    return rng.uniform(0.1, 0.5, size=n)


# ---------------------------------------------------------------------------
# QuantLib reference helper
# ---------------------------------------------------------------------------


def _compute_greeks_quantlib(table):
    """Row-by-row QuantLib BSM Greeks, returning results for valid rows.

    Returns dict with keys: iv, delta, gamma, vega, theta, rho, valid (bool mask).
    """
    n = table.num_rows
    opt = table.column("option_type").to_pylist()
    spot = table.column("spot").to_pylist()
    strike = table.column("strike").to_pylist()
    expiry = table.column("expiry").to_pylist()
    rate = table.column("rate").to_pylist()
    div = table.column("dividend_yield").to_pylist()
    mkt = table.column("market_price").to_pylist()

    calendar = ql.NullCalendar()
    day_count = ql.Actual365Fixed()
    today = ql.Date.todaysDate()
    ql.Settings.instance().evaluationDate = today

    iv_out = np.full(n, np.nan)
    delta_out = np.full(n, np.nan)
    gamma_out = np.full(n, np.nan)
    vega_out = np.full(n, np.nan)
    theta_out = np.full(n, np.nan)
    rho_out = np.full(n, np.nan)
    valid = np.zeros(n, dtype=bool)

    for i in range(n):
        S, K, T, r, q, price = spot[i], strike[i], expiry[i], rate[i], div[i], mkt[i]
        option_type = ql.Option.Call if opt[i] == 1 else ql.Option.Put

        maturity_days = max(int(round(T * 365)), 1)
        maturity = today + ql.Period(maturity_days, ql.Days)

        payoff = ql.PlainVanillaPayoff(option_type, K)
        exercise = ql.EuropeanExercise(maturity)
        option = ql.VanillaOption(payoff, exercise)

        spot_handle = ql.QuoteHandle(ql.SimpleQuote(S))
        rate_curve = ql.YieldTermStructureHandle(
            ql.FlatForward(today, r, day_count)
        )
        div_curve = ql.YieldTermStructureHandle(
            ql.FlatForward(today, q, day_count)
        )
        vol_handle = ql.BlackVolTermStructureHandle(
            ql.BlackConstantVol(today, calendar, 0.20, day_count)
        )

        process = ql.BlackScholesMertonProcess(
            spot_handle, div_curve, rate_curve, vol_handle
        )

        try:
            sigma = option.impliedVolatility(price, process)
        except RuntimeError:
            continue

        solved_vol = ql.BlackVolTermStructureHandle(
            ql.BlackConstantVol(today, calendar, sigma, day_count)
        )
        solved_process = ql.BlackScholesMertonProcess(
            spot_handle, div_curve, rate_curve, solved_vol
        )
        option.setPricingEngine(ql.AnalyticEuropeanEngine(solved_process))

        iv_out[i] = sigma
        delta_out[i] = option.delta()
        gamma_out[i] = option.gamma()
        vega_out[i] = option.vega()
        theta_out[i] = option.theta()
        rho_out[i] = option.rho()
        valid[i] = True

    return {
        "iv": iv_out,
        "delta": delta_out,
        "gamma": gamma_out,
        "vega": vega_out,
        "theta": theta_out,
        "rho": rho_out,
        "valid": valid,
    }


# ---------------------------------------------------------------------------
# Module-scoped fixture: generate data, run argiv + QuantLib once
# ---------------------------------------------------------------------------


@pytest.fixture(scope="module")
def test_data():
    """Generate synthetic dataset and compute Greeks with both argiv and QuantLib."""
    table = generate_dataset(N_ROWS)
    result = argiv.compute_greeks(table)

    # argiv results
    argiv_iv = np.array(result.column("iv").to_pylist())
    argiv_valid = ~np.isnan(argiv_iv)

    # QuantLib reference
    ql_ref = _compute_greeks_quantlib(table)

    # Rows valid in BOTH argiv and QuantLib
    both_valid = argiv_valid & ql_ref["valid"]

    return {
        "table": table,
        "result": result,
        "option_type": np.array(table.column("option_type").to_pylist()),
        "spot": np.array(table.column("spot").to_pylist()),
        "strike": np.array(table.column("strike").to_pylist()),
        "expiry": np.array(table.column("expiry").to_pylist()),
        "rate": np.array(table.column("rate").to_pylist()),
        "dividend_yield": np.array(table.column("dividend_yield").to_pylist()),
        "true_sigma": _true_sigmas(N_ROWS),
        # argiv output
        "argiv_iv": argiv_iv,
        "argiv_delta": np.array(result.column("delta").to_pylist()),
        "argiv_gamma": np.array(result.column("gamma").to_pylist()),
        "argiv_vega": np.array(result.column("vega").to_pylist()),
        "argiv_theta": np.array(result.column("theta").to_pylist()),
        "argiv_rho": np.array(result.column("rho").to_pylist()),
        # QuantLib reference
        "ql_iv": ql_ref["iv"],
        "ql_delta": ql_ref["delta"],
        "ql_gamma": ql_ref["gamma"],
        "ql_vega": ql_ref["vega"],
        "ql_theta": ql_ref["theta"],
        "ql_rho": ql_ref["rho"],
        # masks
        "argiv_valid": argiv_valid,
        "ql_valid": ql_ref["valid"],
        "both_valid": both_valid,
    }


# ---------------------------------------------------------------------------
# Schema / shape tests
# ---------------------------------------------------------------------------


class TestSchema:
    def test_output_has_all_columns(self, test_data):
        result = test_data["result"]
        for col in INPUT_COLS + ["iv", "delta", "gamma", "vega", "theta", "rho"]:
            assert col in result.column_names

    def test_row_count_preserved(self, test_data):
        assert test_data["result"].num_rows == test_data["table"].num_rows

    def test_input_columns_unchanged(self, test_data):
        table = test_data["table"]
        result = test_data["result"]
        for col in INPUT_COLS:
            orig = table.column(col).to_pylist()
            out = result.column(col).to_pylist()
            assert orig == out, f"Input column {col} was modified"


# ---------------------------------------------------------------------------
# IV accuracy
# ---------------------------------------------------------------------------


class TestIVAccuracy:
    def test_iv_close_to_quantlib(self, test_data):
        """99th-percentile IV diff vs QuantLib should be small.

        QuantLib-Python computes T from discrete dates (today + Period(days))
        while argiv takes T directly as a float. This day-count rounding
        causes IV solver divergence especially for short-dated deep ITM/OTM
        options, so we check at the 99th percentile rather than np.all.
        """
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_iv"][m] - test_data["ql_iv"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 2e-3, f"P99 IV diff {p99:.2e} >= 2e-3"

    def test_iv_recovery(self, test_data):
        """argiv should recover the true sigma used to generate prices."""
        m = test_data["argiv_valid"]
        diff = np.abs(test_data["argiv_iv"][m] - test_data["true_sigma"][m])
        assert np.all(diff < 1e-4), f"Max IV recovery diff {diff.max():.2e}"


# ---------------------------------------------------------------------------
# Greeks accuracy vs QuantLib (one test per Greek)
#
# Tolerances are 99th-percentile based because QuantLib-Python discretizes T
# to integer days while argiv uses the exact float T. Measured distributions:
#   delta  p99 ~ 6e-4    → threshold 1e-3
#   gamma  p99 ~ 6e-5    → threshold 1e-4
#   vega   p99 ~ 7e-2    → threshold 0.1
#   theta  p99 ~ 7e-2    → threshold 0.1
#   rho    p99 ~ 1e-1    → threshold 0.2
# ---------------------------------------------------------------------------


class TestGreeksAccuracy:
    def test_delta_close_to_quantlib(self, test_data):
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_delta"][m] - test_data["ql_delta"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 1e-3, f"P99 delta diff {p99:.2e}"

    def test_gamma_close_to_quantlib(self, test_data):
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_gamma"][m] - test_data["ql_gamma"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 1e-4, f"P99 gamma diff {p99:.2e}"

    def test_vega_close_to_quantlib(self, test_data):
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_vega"][m] - test_data["ql_vega"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 0.1, f"P99 vega diff {p99:.2e}"

    def test_theta_close_to_quantlib(self, test_data):
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_theta"][m] - test_data["ql_theta"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 0.1, f"P99 theta diff {p99:.2e}"

    def test_rho_close_to_quantlib(self, test_data):
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_rho"][m] - test_data["ql_rho"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 0.2, f"P99 rho diff {p99:.2e}"


# ---------------------------------------------------------------------------
# Greeks sign conventions
# ---------------------------------------------------------------------------


class TestGreeksSigns:
    def test_call_delta_in_range(self, test_data):
        m = test_data["argiv_valid"] & (test_data["option_type"] == 1)
        delta = test_data["argiv_delta"][m]
        assert np.all((delta > 0) & (delta < 1)), "Call delta out of (0, 1)"

    def test_put_delta_in_range(self, test_data):
        m = test_data["argiv_valid"] & (test_data["option_type"] == -1)
        delta = test_data["argiv_delta"][m]
        assert np.all((delta > -1) & (delta < 0)), "Put delta out of (-1, 0)"

    def test_gamma_positive(self, test_data):
        m = test_data["argiv_valid"]
        gamma = test_data["argiv_gamma"][m]
        assert np.all(gamma > 0), "Some gammas are non-positive"

    def test_vega_positive(self, test_data):
        m = test_data["argiv_valid"]
        vega = test_data["argiv_vega"][m]
        assert np.all(vega > 0), "Some vegas are non-positive"

    def test_call_rho_positive(self, test_data):
        m = test_data["argiv_valid"] & (test_data["option_type"] == 1)
        rho = test_data["argiv_rho"][m]
        assert np.all(rho > 0), "Some call rhos are non-positive"

    def test_put_rho_negative(self, test_data):
        m = test_data["argiv_valid"] & (test_data["option_type"] == -1)
        rho = test_data["argiv_rho"][m]
        assert np.all(rho < 0), "Some put rhos are non-negative"


# ---------------------------------------------------------------------------
# Consistency checks
# ---------------------------------------------------------------------------


class TestConsistency:
    def test_put_call_delta_parity(self, test_data):
        """Verify put-call parity on delta using argiv's own results.

        generate_dataset draws random strikes/expiries so there are no exact
        call/put pairs. Instead, we compute both call and put prices for a
        fixed grid and verify call_delta - put_delta ~ exp(-q*T).
        """
        import pyarrow as pa
        from argiv.helpers import _bs_call_price, _bs_put_price

        S, K, T, r, q, sigma = 100.0, 100.0, 1.0, 0.05, 0.01, 0.2
        call_price = _bs_call_price(S, K, T, r, q, sigma)
        put_price = _bs_put_price(S, K, T, r, q, sigma)

        table = pa.table({
            "option_type": pa.array([1, -1], type=pa.int32()),
            "spot": pa.array([S, S], type=pa.float64()),
            "strike": pa.array([K, K], type=pa.float64()),
            "expiry": pa.array([T, T], type=pa.float64()),
            "rate": pa.array([r, r], type=pa.float64()),
            "dividend_yield": pa.array([q, q], type=pa.float64()),
            "market_price": pa.array([call_price, put_price], type=pa.float64()),
        })
        result = argiv.compute_greeks(table)
        call_delta = result.column("delta")[0].as_py()
        put_delta = result.column("delta")[1].as_py()

        expected = math.exp(-q * T)
        actual = call_delta - put_delta
        assert abs(actual - expected) < 1e-6, (
            f"Put-call delta parity: {actual:.8f} vs exp(-qT)={expected:.8f}"
        )

    def test_determinism(self, test_data):
        """Running compute_greeks twice on the same input gives identical results."""
        table = test_data["table"]
        result2 = argiv.compute_greeks(table)

        for col in ["iv", "delta", "gamma", "vega", "theta", "rho"]:
            a = np.array(test_data["result"].column(col).to_pylist())
            b = np.array(result2.column(col).to_pylist())
            match = (np.isnan(a) & np.isnan(b)) | (a == b)
            assert np.all(match), f"Column {col} not reproducible"
