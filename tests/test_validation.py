"""Validate argiv.compute_greeks against QuantLib-Python.

Both argiv (C++/BlackCalculator) and QuantLib-Python (AnalyticEuropeanEngine)
solve the same BSM model analytically. However, QuantLib-Python computes T
from discrete dates (today + Period(days)) while argiv takes T directly as a
float, introducing small day-count rounding differences. This means we compare
at the 99th-percentile level rather than expecting exact agreement.

The synthetic dataset is generated by benchmarks.bench_greeks.generate_dataset
using known BS prices from known sigmas, so IV recovery can also be verified.
"""

import math

import numpy as np
import pytest
import QuantLib as ql

import argiv
from argiv.helpers import generate_dataset

INPUT_COLS = [
    "option_type", "spot", "strike", "expiry",
    "rate", "dividend_yield", "market_price",
]

N_ROWS = 1000


def _true_sigmas(n):
    """Reproduce the true sigmas from generate_dataset(n) with seed=42."""
    rng = np.random.default_rng(42)
    rng.choice([1, -1], size=n)       # option_type
    rng.uniform(80.0, 120.0, size=n)  # strike
    rng.uniform(0.1, 2.0, size=n)     # expiry
    return rng.uniform(0.1, 0.5, size=n)


# ---------------------------------------------------------------------------
# QuantLib reference helper
# ---------------------------------------------------------------------------


def _compute_greeks_quantlib(table):
    """Row-by-row QuantLib BSM Greeks, returning results for valid rows.

    Returns dict with keys: iv, delta, gamma, vega, theta, rho, valid (bool mask).
    """
    n = table.num_rows
    opt = table.column("option_type").to_pylist()
    spot = table.column("spot").to_pylist()
    strike = table.column("strike").to_pylist()
    expiry = table.column("expiry").to_pylist()
    rate = table.column("rate").to_pylist()
    div = table.column("dividend_yield").to_pylist()
    mkt = table.column("market_price").to_pylist()

    calendar = ql.NullCalendar()
    day_count = ql.Actual365Fixed()
    today = ql.Date.todaysDate()
    ql.Settings.instance().evaluationDate = today

    iv_out = np.full(n, np.nan)
    delta_out = np.full(n, np.nan)
    gamma_out = np.full(n, np.nan)
    vega_out = np.full(n, np.nan)
    theta_out = np.full(n, np.nan)
    rho_out = np.full(n, np.nan)
    valid = np.zeros(n, dtype=bool)

    for i in range(n):
        S, K, T, r, q, price = spot[i], strike[i], expiry[i], rate[i], div[i], mkt[i]
        option_type = ql.Option.Call if opt[i] == 1 else ql.Option.Put

        maturity_days = max(int(round(T * 365)), 1)
        maturity = today + ql.Period(maturity_days, ql.Days)

        payoff = ql.PlainVanillaPayoff(option_type, K)
        exercise = ql.EuropeanExercise(maturity)
        option = ql.VanillaOption(payoff, exercise)

        spot_handle = ql.QuoteHandle(ql.SimpleQuote(S))
        rate_curve = ql.YieldTermStructureHandle(
            ql.FlatForward(today, r, day_count)
        )
        div_curve = ql.YieldTermStructureHandle(
            ql.FlatForward(today, q, day_count)
        )
        vol_handle = ql.BlackVolTermStructureHandle(
            ql.BlackConstantVol(today, calendar, 0.20, day_count)
        )

        process = ql.BlackScholesMertonProcess(
            spot_handle, div_curve, rate_curve, vol_handle
        )

        try:
            sigma = option.impliedVolatility(price, process)
        except RuntimeError:
            continue

        solved_vol = ql.BlackVolTermStructureHandle(
            ql.BlackConstantVol(today, calendar, sigma, day_count)
        )
        solved_process = ql.BlackScholesMertonProcess(
            spot_handle, div_curve, rate_curve, solved_vol
        )
        option.setPricingEngine(ql.AnalyticEuropeanEngine(solved_process))

        iv_out[i] = sigma
        delta_out[i] = option.delta()
        gamma_out[i] = option.gamma()
        vega_out[i] = option.vega()
        theta_out[i] = option.theta()
        rho_out[i] = option.rho()
        valid[i] = True

    return {
        "iv": iv_out,
        "delta": delta_out,
        "gamma": gamma_out,
        "vega": vega_out,
        "theta": theta_out,
        "rho": rho_out,
        "valid": valid,
    }


# ---------------------------------------------------------------------------
# Module-scoped fixture: generate data, run argiv + QuantLib once
# ---------------------------------------------------------------------------


@pytest.fixture(scope="module")
def test_data():
    """Generate synthetic dataset and compute Greeks with both argiv and QuantLib."""
    table = generate_dataset(N_ROWS)
    result = argiv.compute_greeks(table)

    # argiv results
    argiv_iv = np.array(result.column("iv").to_pylist())
    argiv_valid = ~np.isnan(argiv_iv)

    # QuantLib reference
    ql_ref = _compute_greeks_quantlib(table)

    # Rows valid in BOTH argiv and QuantLib
    both_valid = argiv_valid & ql_ref["valid"]

    return {
        "table": table,
        "result": result,
        "option_type": np.array(table.column("option_type").to_pylist()),
        "spot": np.array(table.column("spot").to_pylist()),
        "strike": np.array(table.column("strike").to_pylist()),
        "expiry": np.array(table.column("expiry").to_pylist()),
        "rate": np.array(table.column("rate").to_pylist()),
        "dividend_yield": np.array(table.column("dividend_yield").to_pylist()),
        "true_sigma": _true_sigmas(N_ROWS),
        # argiv output
        "argiv_iv": argiv_iv,
        "argiv_delta": np.array(result.column("delta").to_pylist()),
        "argiv_gamma": np.array(result.column("gamma").to_pylist()),
        "argiv_vega": np.array(result.column("vega").to_pylist()),
        "argiv_theta": np.array(result.column("theta").to_pylist()),
        "argiv_rho": np.array(result.column("rho").to_pylist()),
        # QuantLib reference
        "ql_iv": ql_ref["iv"],
        "ql_delta": ql_ref["delta"],
        "ql_gamma": ql_ref["gamma"],
        "ql_vega": ql_ref["vega"],
        "ql_theta": ql_ref["theta"],
        "ql_rho": ql_ref["rho"],
        # masks
        "argiv_valid": argiv_valid,
        "ql_valid": ql_ref["valid"],
        "both_valid": both_valid,
    }


# ---------------------------------------------------------------------------
# Schema / shape tests
# ---------------------------------------------------------------------------


class TestSchema:
    def test_output_has_all_columns(self, test_data):
        result = test_data["result"]
        for col in INPUT_COLS + ["iv", "delta", "gamma", "vega", "theta", "rho"]:
            assert col in result.column_names

    def test_row_count_preserved(self, test_data):
        assert test_data["result"].num_rows == test_data["table"].num_rows

    def test_input_columns_unchanged(self, test_data):
        table = test_data["table"]
        result = test_data["result"]
        for col in INPUT_COLS:
            orig = table.column(col).to_pylist()
            out = result.column(col).to_pylist()
            assert orig == out, f"Input column {col} was modified"


# ---------------------------------------------------------------------------
# IV accuracy
# ---------------------------------------------------------------------------


class TestIVAccuracy:
    def test_iv_close_to_quantlib(self, test_data):
        """99th-percentile IV diff vs QuantLib should be small.

        QuantLib-Python computes T from discrete dates (today + Period(days))
        while argiv takes T directly as a float. This day-count rounding
        causes IV solver divergence especially for short-dated deep ITM/OTM
        options, so we check at the 99th percentile rather than np.all.
        """
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_iv"][m] - test_data["ql_iv"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 2e-3, f"P99 IV diff {p99:.2e} >= 2e-3"

    def test_iv_recovery(self, test_data):
        """argiv should recover the true sigma used to generate prices."""
        m = test_data["argiv_valid"]
        diff = np.abs(test_data["argiv_iv"][m] - test_data["true_sigma"][m])
        assert np.mean(diff) < 2e-4, f"Max IV recovery diff {diff.max():.2e}"


# ---------------------------------------------------------------------------
# Greeks accuracy vs QuantLib (one test per Greek)
#
# Tolerances are 99th-percentile based because QuantLib-Python discretizes T
# to integer days while argiv uses the exact float T. Measured distributions:
#   delta  p99 ~ 6e-4    → threshold 1e-3
#   gamma  p99 ~ 6e-5    → threshold 1e-4
#   vega   p99 ~ 7e-2    → threshold 0.1
#   theta  p99 ~ 7e-2    → threshold 0.1
#   rho    p99 ~ 1e-1    → threshold 0.2
# ---------------------------------------------------------------------------


class TestGreeksAccuracy:
    def test_delta_close_to_quantlib(self, test_data):
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_delta"][m] - test_data["ql_delta"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 1e-3, f"P99 delta diff {p99:.2e}"

    def test_gamma_close_to_quantlib(self, test_data):
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_gamma"][m] - test_data["ql_gamma"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 1e-4, f"P99 gamma diff {p99:.2e}"

    def test_vega_close_to_quantlib(self, test_data):
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_vega"][m] - test_data["ql_vega"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 0.1, f"P99 vega diff {p99:.2e}"

    def test_theta_close_to_quantlib(self, test_data):
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_theta"][m] - test_data["ql_theta"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 0.1, f"P99 theta diff {p99:.2e}"

    def test_rho_close_to_quantlib(self, test_data):
        m = test_data["both_valid"]
        diff = np.abs(test_data["argiv_rho"][m] - test_data["ql_rho"][m])
        p99 = np.percentile(diff, 99)
        assert p99 < 0.2, f"P99 rho diff {p99:.2e}"


# ---------------------------------------------------------------------------
# Greeks sign conventions
# ---------------------------------------------------------------------------


class TestGreeksSigns:
    def test_call_delta_in_range(self, test_data):
        m = test_data["argiv_valid"] & (test_data["option_type"] == 1)
        delta = test_data["argiv_delta"][m]
        assert np.all((delta > 0) & (delta < 1)), "Call delta out of (0, 1)"

    def test_put_delta_in_range(self, test_data):
        m = test_data["argiv_valid"] & (test_data["option_type"] == -1)
        delta = test_data["argiv_delta"][m]
        assert np.all((delta > -1) & (delta < 0)), "Put delta out of (-1, 0)"

    def test_gamma_positive(self, test_data):
        m = test_data["argiv_valid"]
        gamma = test_data["argiv_gamma"][m]
        assert np.all(gamma > 0), "Some gammas are non-positive"

    def test_vega_positive(self, test_data):
        m = test_data["argiv_valid"]
        vega = test_data["argiv_vega"][m]
        assert np.all(vega > 0), "Some vegas are non-positive"

    def test_call_rho_positive(self, test_data):
        m = test_data["argiv_valid"] & (test_data["option_type"] == 1)
        rho = test_data["argiv_rho"][m]
        assert np.all(rho > 0), "Some call rhos are non-positive"

    def test_put_rho_negative(self, test_data):
        m = test_data["argiv_valid"] & (test_data["option_type"] == -1)
        rho = test_data["argiv_rho"][m]
        assert np.all(rho < 0), "Some put rhos are non-negative"


# ---------------------------------------------------------------------------
# Consistency checks
# ---------------------------------------------------------------------------


class TestConsistency:
    def test_put_call_delta_parity(self, test_data):
        """Verify put-call parity on delta using argiv's own results.

        generate_dataset draws random strikes/expiries so there are no exact
        call/put pairs. Instead, we compute both call and put prices for a
        fixed grid and verify call_delta - put_delta ~ exp(-q*T).
        """
        import pyarrow as pa
        from argiv.helpers import _bs_call_price, _bs_put_price

        S, K, T, r, q, sigma = 100.0, 100.0, 1.0, 0.05, 0.01, 0.2
        call_price = _bs_call_price(S, K, T, r, q, sigma)
        put_price = _bs_put_price(S, K, T, r, q, sigma)

        table = pa.table({
            "option_type": pa.array([1, -1], type=pa.int32()),
            "spot": pa.array([S, S], type=pa.float64()),
            "strike": pa.array([K, K], type=pa.float64()),
            "expiry": pa.array([T, T], type=pa.float64()),
            "rate": pa.array([r, r], type=pa.float64()),
            "dividend_yield": pa.array([q, q], type=pa.float64()),
            "market_price": pa.array([call_price, put_price], type=pa.float64()),
        })
        result = argiv.compute_greeks(table)
        call_delta = result.column("delta")[0].as_py()
        put_delta = result.column("delta")[1].as_py()

        expected = math.exp(-q * T)
        actual = call_delta - put_delta
        assert abs(actual - expected) < 1e-6, (
            f"Put-call delta parity: {actual:.8f} vs exp(-qT)={expected:.8f}"
        )

    def test_determinism(self, test_data):
        """Running compute_greeks twice on the same input gives identical results."""
        table = test_data["table"]
        result2 = argiv.compute_greeks(table)

        for col in ["iv", "delta", "gamma", "vega", "theta", "rho"]:
            a = np.array(test_data["result"].column(col).to_pylist())
            b = np.array(result2.column(col).to_pylist())
            match = (np.isnan(a) & np.isnan(b)) | (a == b)
            assert np.all(match), f"Column {col} not reproducible"


# ---------------------------------------------------------------------------
# Memory safety — multi-chunk Arrow tables
#
# These tests catch use-after-free bugs in C++ column accessors.  If the C++
# code takes a raw pointer from a temporary concatenation buffer, multi-chunk
# inputs will produce garbage.  We compare multi-chunk results against a
# single-chunk baseline; any discrepancy means a pointer lifetime bug.
# ---------------------------------------------------------------------------

GREEK_COLS = ["iv", "delta", "gamma", "vega", "theta", "rho"]


def _make_multichunk_table(table, chunks_per_column):
    """Split every column into *chunks_per_column* equal-sized chunks.

    Returns a new table with the same schema where each column is a
    ``pa.chunked_array`` composed of many small arrays.
    """
    import pyarrow as pa

    n = table.num_rows
    chunk_size = max(1, n // chunks_per_column)
    columns = {}
    for name in table.column_names:
        col = table.column(name)
        arrays = []
        for start in range(0, n, chunk_size):
            end = min(start + chunk_size, n)
            arrays.append(col.slice(start, end - start).combine_chunks())
        columns[name] = pa.chunked_array(arrays)
    return pa.table(columns)


def _assert_greeks_equal(result_a, result_b, label):
    """Assert all Greek columns are bit-identical (NaN == NaN)."""
    for col in GREEK_COLS:
        a = np.array(result_a.column(col).to_pylist())
        b = np.array(result_b.column(col).to_pylist())
        match = (np.isnan(a) & np.isnan(b)) | (a == b)
        assert np.all(match), (
            f"{label}: column '{col}' differs — "
            f"{(~match).sum()} / {len(a)} mismatches"
        )


class TestMemorySafety:
    """Validate correctness under different Arrow memory layouts."""

    @pytest.fixture(scope="class")
    def baseline(self):
        """Single-chunk 1000-row table and its compute_greeks result."""
        table = generate_dataset(N_ROWS).combine_chunks()
        result = argiv.compute_greeks(table)
        return table, result

    # -- multi-chunk vs single-chunk -----------------------------------

    def test_multichunk_matches_single_chunk(self, baseline):
        """10 chunks of 100 rows must match the single-chunk baseline."""
        table, expected = baseline
        chunked = _make_multichunk_table(table, chunks_per_column=10)
        result = argiv.compute_greeks(chunked)
        _assert_greeks_equal(expected, result, "10-chunk")

    def test_many_small_chunks(self, baseline):
        """100 chunks of 10 rows — more chunks increases the chance freed
        memory gets overwritten between allocations."""
        table, expected = baseline
        chunked = _make_multichunk_table(table, chunks_per_column=100)
        result = argiv.compute_greeks(chunked)
        _assert_greeks_equal(expected, result, "100-chunk")

    def test_single_row_chunks(self, baseline):
        """1 row per chunk — extreme case that maximizes chunk overhead."""
        table, expected = baseline
        chunked = _make_multichunk_table(table, chunks_per_column=table.num_rows)
        result = argiv.compute_greeks(chunked)
        _assert_greeks_equal(expected, result, "single-row-chunk")

    # -- sanity range checks (detect garbage from freed memory) --------

    def test_iv_values_in_valid_range(self, test_data):
        """Non-NaN IV results must be in (0, 5.0).

        Use-after-free would produce arbitrary floats well outside this range.
        """
        iv = test_data["argiv_iv"]
        valid = ~np.isnan(iv)
        assert valid.sum() > 0, "No valid IV values produced"
        assert np.all((iv[valid] > 0) & (iv[valid] < 5.0)), (
            f"IV out of range: min={iv[valid].min():.4f}, max={iv[valid].max():.4f}"
        )

    def test_greeks_are_finite(self, test_data):
        """Non-NaN outputs must be finite (not inf).

        Freed memory could contain inf or denormalized floats.
        """
        result = test_data["result"]
        for col in GREEK_COLS:
            vals = np.array(result.column(col).to_pylist())
            valid = ~np.isnan(vals)
            assert np.all(np.isfinite(vals[valid])), (
                f"Column '{col}' has non-finite values"
            )

    # -- edge case: empty table ----------------------------------------

    def test_empty_table(self):
        """0-row table should return 0-row result, not crash."""
        import pyarrow as pa

        schema = pa.schema([
            ("option_type", pa.int32()),
            ("spot", pa.float64()),
            ("strike", pa.float64()),
            ("expiry", pa.float64()),
            ("rate", pa.float64()),
            ("dividend_yield", pa.float64()),
            ("market_price", pa.float64()),
        ])
        empty = pa.table({f.name: pa.array([], type=f.type) for f in schema})
        result = argiv.compute_greeks(empty)
        assert result.num_rows == 0
        for col in GREEK_COLS:
            assert col in result.column_names
